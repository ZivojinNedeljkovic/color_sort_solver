{"mappings":"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","sources":["src/bottle.ts","src/node.ts","src/step.ts","src/solutionSearch.ts","src/game.ts","src/worker.ts"],"sourcesContent":["export type Bottle = string[]\r\n\r\nconst getTopColor = (bottle: Bottle) => bottle[bottle.length - 1]\r\n\r\nconst canPour = (fromBottle: Bottle, toBottle: Bottle) =>\r\n  fromBottle.length > 0 &&\r\n  toBottle.length < 4 &&\r\n  (getTopColor(fromBottle) === getTopColor(toBottle) || toBottle.length === 0)\r\n\r\nfunction hasOnlyOneColor(bottle: Bottle) {\r\n  for (const color of bottle) {\r\n    if (color !== bottle[0]) return false\r\n  }\r\n  return true\r\n}\r\n\r\nconst shodPour = (fromBottle: Bottle, toBottle: Bottle) =>\r\n  !(hasOnlyOneColor(fromBottle) && toBottle.length === 0)\r\n\r\nexport function pour(fromBottle: Bottle, toBottle: Bottle) {\r\n  if (!(canPour(fromBottle, toBottle) && shodPour(fromBottle, toBottle))) return\r\n  ;[fromBottle, toBottle] = [[...fromBottle], [...toBottle]]\r\n\r\n  do {\r\n    toBottle.push(fromBottle.pop()!)\r\n  } while (canPour(fromBottle, toBottle))\r\n\r\n  return { emptiedBottle: fromBottle, filledBottle: toBottle }\r\n}\r\n\r\nexport const isClosedBottle = (bottle: Bottle) =>\r\n  bottle.length === 4 && hasOnlyOneColor(bottle)\r\n\r\nexport const areEqualBottles = (bottle1: Bottle, bottle2: Bottle) => {\r\n  if (bottle1 === bottle2) return true\r\n\r\n  if (bottle1.length !== bottle2.length) return false\r\n\r\n  for (let i = 0; i < bottle1.length; i++) {\r\n    if (bottle1[i] !== bottle2[i]) return false\r\n  }\r\n\r\n  return true\r\n}\r\n","class Node<T> {\r\n  children: Node<T>[] = []\r\n\r\n  constructor(public key: T, public parent: Node<T> | undefined) {}\r\n\r\n  private _hasUniqueKeyInBranch(\r\n    areEqualKeys: (key1: T, key2: T) => boolean,\r\n    ancestorNode: Node<T> | undefined\r\n  ): boolean {\r\n    if (!ancestorNode) return true\r\n\r\n    if (areEqualKeys(this.key, ancestorNode.key)) return false\r\n\r\n    return this._hasUniqueKeyInBranch(areEqualKeys, ancestorNode.parent)\r\n  }\r\n\r\n  hasUniqueKeyInBranch(areEqualKeys: (key1: T, key2: T) => boolean) {\r\n    return this._hasUniqueKeyInBranch(areEqualKeys, this.parent)\r\n  }\r\n\r\n  getBranchKeys() {\r\n    const ancestryKeys: T[] = []\r\n    let branchNode: Node<T> | undefined = this\r\n\r\n    while (branchNode) {\r\n      ancestryKeys.push(branchNode.key)\r\n      branchNode = branchNode.parent\r\n    }\r\n\r\n    return ancestryKeys.reverse()\r\n  }\r\n}\r\n\r\nexport default Node\r\n","import { areEqualBottles, Bottle } from './bottle'\r\n\r\nexport type Step = Bottle[]\r\n\r\nexport function areEqualSteps(step1: Step, step2: Step) {\r\n  if (step1.length !== step1.length) return false\r\n\r\n  for (let i = 0; i < step1.length; i++) {\r\n    if (!areEqualBottles(step1[i], step2[i])) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  return true\r\n}\r\n","import { Bottle, pour } from './bottle'\r\nimport { isGameWon } from './game'\r\nimport Node from './node'\r\nimport { areEqualSteps, Step } from './step'\r\n\r\nclass SolutionSearch {\r\n  private bestMoveCount = Number.MAX_SAFE_INTEGER\r\n\r\n  constructor(\r\n    bottles: Bottle[],\r\n    private onFindSolution: (solution: Step[]) => void\r\n  ) {\r\n    this.search(new Node(bottles, undefined))\r\n  }\r\n\r\n  private removeLastAddedNodeFromParent<T>(node: Node<T>) {\r\n    node.parent?.children.pop()\r\n  }\r\n\r\n  private search(node: Node<Step>, moveCount = 0) {\r\n    if (\r\n      moveCount >= this.bestMoveCount ||\r\n      !node.hasUniqueKeyInBranch(areEqualSteps)\r\n    ) {\r\n      this.removeLastAddedNodeFromParent(node)\r\n      return\r\n    }\r\n\r\n    const bottles = node.key\r\n\r\n    if (isGameWon(bottles)) {\r\n      this.onFindSolution(node.getBranchKeys())\r\n      this.bestMoveCount = moveCount\r\n      return\r\n    }\r\n\r\n    bottles.forEach((fromBottle, i) => {\r\n      bottles.forEach((toBottle, j) => {\r\n        if (i === j) return\r\n\r\n        const changedBottles = pour(fromBottle, toBottle)\r\n\r\n        if (!changedBottles) return\r\n\r\n        const { emptiedBottle, filledBottle } = changedBottles\r\n\r\n        const nextStep = [...bottles]\r\n\r\n        nextStep[i] = emptiedBottle\r\n        nextStep[j] = filledBottle\r\n\r\n        const newNode = new Node(nextStep, node)\r\n\r\n        node.children.push(newNode)\r\n\r\n        this.search(newNode, moveCount + 1)\r\n      })\r\n    })\r\n\r\n    if (node.children.length === 0) this.removeLastAddedNodeFromParent(node)\r\n  }\r\n}\r\n\r\nexport default SolutionSearch\r\n","import { Bottle, isClosedBottle } from \"./bottle\"\r\n\r\n\r\nexport function isGameWon(bottles: Bottle[]) {\r\n  for (const bottle of bottles) {\r\n    if (!(isClosedBottle(bottle) || bottle.length === 0)) return false\r\n  }\r\n\r\n  return true\r\n}\r\n","import { Bottle } from './bottle'\r\nimport SolutionSearch from './solutionSearch'\r\n\r\n// const isArrayOfStrings = (data: any) =>\r\n//   Array.isArray(data) && data.every(el => typeof el === 'string')\r\n\r\n// onmessage = function ({ data: bottlesAsString }: MessageEvent<string>) {\r\n//   console.log('hello from worker')\r\n\r\n//   let bottles: Bottle[]\r\n//   try {\r\n//     bottles = JSON.parse(bottlesAsString)\r\n\r\n//     if (!isArrayOfStrings(bottles)) throw new Error('Invalid input data')\r\n//   } catch (err: any) {\r\n//     postMessage({ error: err.message })\r\n//     return\r\n//   }\r\n\r\n//   new SolutionSearch(bottles, solution => postMessage({ solution }))\r\n\r\n//   postMessage({ finished: true })\r\n// }\r\n\r\nonmessage = function (bottlesAsString: MessageEvent<string>) {\r\n  console.log('hello from worker')\r\n  const bottles: Bottle[] = JSON.parse(bottlesAsString.data)\r\n\r\n  let foundSolution = false\r\n\r\n  new SolutionSearch(bottles, solution => {\r\n    foundSolution = true\r\n    postMessage(JSON.stringify(solution))\r\n  })\r\n\r\n  if (!foundSolution) postMessage(JSON.stringify([]))\r\n}\r\n"],"names":["$b3daf550d72d25c2$var$getTopColor","bottle","length","$b3daf550d72d25c2$var$canPour","fromBottle","toBottle","$b3daf550d72d25c2$var$hasOnlyOneColor","color","$b3daf550d72d25c2$export$74c27a9c882a3f71","$b3daf550d72d25c2$var$shodPour","push","pop","emptiedBottle","filledBottle","$b3daf550d72d25c2$export$21c597f58d486f9","$b3daf550d72d25c2$export$912ebf39a4c23e9f","bottle1","bottle2","i","$17975fa0d9a06ffd$export$2e2bcd8739ae039","key","parent","this","children","_hasUniqueKeyInBranch","areEqualKeys","ancestorNode","hasUniqueKeyInBranch","getBranchKeys","ancestryKeys","branchNode","reverse","$6531d5bf0b162d50$export$2eac8ed453703230","step1","step2","$8cdb48ed8e58468e$export$2e2bcd8739ae039","bottles","onFindSolution","bestMoveCount","Number","MAX_SAFE_INTEGER","search","undefined","removeLastAddedNodeFromParent","node","moveCount","$c9e0023f02f54297$export$c7a6dae52d455f73","forEach","j","changedBottles","nextStep","newNode","onmessage","bottlesAsString","console","log","JSON","parse","data","foundSolution","solution","postMessage","stringify"],"version":3,"file":"worker.js.map"}